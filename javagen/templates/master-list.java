<?nextrec?>
<?definegroup 1 =$itemclass$=?>
<?ifendgroup 1 ?>
<?ifnewgroup 1 ?>
<?if =$itemtype$= = "Master" ?>
<?set masterItemClass = =$itemclass$= ?>
<?output "../../src/com/powersurgepub/clubplanner/model/=$itemclass$=List.java"?>
package com.powersurgepub.clubplanner.model;

  import com.powersurgepub.psdatalib.pstags.*;
  import com.powersurgepub.regcodes.*;
  import java.io.*;
  import java.util.*;
  import javax.swing.table.*;

  /* 
   This item master list class generated by PSTextMerge using: 
   
     template:  =$templatefilename$=
     data file: =$datafilename$=
   */

/**
 A list of =$itemclass$= items stored in memory.

 @author Herb Bowie
 */
public class =$itemclass$=List 
    extends AbstractTableModel
    implements TaggableList {
    
  private String          title = "=$itemclass&c uul$= List";
  
  private List<=$itemclass$=>            list = new ArrayList();
  
  private int             findIndex = -1;
  private boolean         findMatch = false;
  
  private TagsList        tagsList = new TagsList();
  private TagsModel       tagsModel = new TagsModel();
  
  /**
   List constructor with no arguments. 
   */
  public =$itemclass$=List () {
    tagsList.registerValue("");
  }
  
  public TagsList getTagsList () {
    return tagsList;
  }

  public TagsModel getTagsModel () {
    return tagsModel;
  }
  
  /**
   Set the data source, stored in the root node of the TagsModel tree. 
  
   @param source The file or folder from which the data is taken. 
  */
  public void setSource (File source) {
    tagsModel.setSource(source);
  }
  
  /**
   Get the data source, stored in the root node of the TagsModel tree. 
  
   @return The file or folder from which the data is taken. 
  */
  public File getSource () {
    return tagsModel.getSource();
  }
  
  public void setTitle (String title) {
    this.title = title;
  }

  public String getTitle () {
    return title;
  }
  
  /**
   Return the number of columns.
   */
  public int getColumnCount () {
    return =$itemclass$=.getColumnCount();
  }
  
  public String getColumnName (int columnIndex) {
    return =$itemclass$=.getColumnName (columnIndex);
  }

  public Class getColumnClass (int columnIndex) {
    return =$itemclass$=.getColumnClass (columnIndex);
  }
  
  /**
   Can more records/items be added without exceeding the demo limitation?

   @return     True if more can be added, false if we've hit the ceiling.
   */
  public boolean roomForMore() {
    return RegisterWindow.getShared().roomForMore(size());
  }
  
  /**
   Return the size of the list. 
   */
  public int size() {
    return list.size();
  }

  /**
   Return the number of rows in the table. 
   */
  public int getRowCount() {
    return list.size();
  }
  
  /**
   Return the column value of the item at the specified index. 
   */
  public String getValueAt (int rowIndex, int columnIndex) {
    =$itemclass$= item = get(rowIndex);
    if (item == null) {
      return "";
    } else {
      Object columnValue = item.getColumnValue(columnIndex);
      if (columnValue == null) {
        return "";
      } else {
        return columnValue.toString();
      }
    }
  } // end method getValueAt
  
  /**
   Get the item at the specified index. 
  
   @param index Indicates the desired position. 
  
   @return The item at the desired index, or null if the index is out
           of bounds. 
  */
  public =$itemclass$= get (int index) {
    if (index >= 0 && index < list.size()) {
      return list.get(index);
    } else {
      return null;
    }
  } // end method get (int)
  
  public =$itemclass$=Positioned positionUsingNode (TagsNode node) {
    =$itemclass$=Positioned position = new =$itemclass$=Positioned();
    position.set=$itemclass$= ((=$itemclass$=)node.getTaggable());
    position.setTagsNode (node);
    findInternal (position.get=$itemclass$=());
    position.setIndex (findIndex);
    position.setNavigator (=$itemclass$=Positioned.NAVIGATE_USING_TREE);
    return position;
  }
  
  /**
   Add a new =$itemclass$= to the list, or merge it with an existing one if another
   with the same =$itemclass$= already exists. Maintain the list in ascending sequence
   by the =$itemclass$= key.
   
   @param new=$itemclass$=
   @return A positioned =$itemclass$= composed of the resulting =$itemclass$= and an index
           pointing to its resulting position in the list.
   */
  public =$itemclass$=Positioned add (=$itemclass$= new=$itemclass$=) {
    // System.out.println ("adding: " + new=$itemclass$=.toString());
    // System.out.println ("URLCollection add " + new=$itemclass$=.toString());
    // new=$itemclass$=.getTags().displayTags();
    =$itemclass$= resulting=$itemclass$= = new=$itemclass$=;
    boolean merged = false;
    if (list.isEmpty()) {
      // If this is the first =$itemclass$= being added to the collection, simply add it
      list.add (new=$itemclass$=);
      findIndex = 0;
    }
    else
    if (get(list.size() - 1).compareTo(new=$itemclass$=) < 0) {
      // If the new URL has a key higher than the highest item in the
      // collection, simply add the new URL to the end
      // (more efficient if an input file happens to be pre-sorted).
      findIndex = list.size();
      list.add (new=$itemclass$=);
    } else {
      findInternal (new=$itemclass$=);
      if (findMatch) {
        get(findIndex).merge(new=$itemclass$=);
        resulting=$itemclass$= = get(findIndex);
        merged = true;
      } else {
        list.add (findIndex, new=$itemclass$=);
      }
    }
    
    if (merged) {
      tagsList.modify  (resulting=$itemclass$=);
      tagsModel.modify (resulting=$itemclass$=);
    } else {
      tagsList.add  (resulting=$itemclass$=);
      tagsModel.add (resulting=$itemclass$=);
    }

    return new =$itemclass$=Positioned (resulting=$itemclass$=, findIndex);
  } // end add method

  public =$itemclass$=Positioned modify (=$itemclass$=Positioned mod=$itemclass$=) {
    tagsList.modify(mod=$itemclass$=.get=$itemclass$=());
    tagsModel.modify(mod=$itemclass$=.get=$itemclass$=());
    return mod=$itemclass$=;
  }

  /**
   Removes the passed =$itemclass$=, if it exists in the collection.

   @param position A position containing the =$itemclass$= to be removed.
   
   @return A position for the next URL following the one just removed.
   */
  public =$itemclass$=Positioned remove (=$itemclass$=Positioned position) {
    int oldIndex = find (position.get=$itemclass$=());
    =$itemclass$=Positioned newPosition = position;
    if (findMatch) {
      newPosition = next (position);
      tagsModel.remove (position.get=$itemclass$=());
      tagsList.remove (position.get=$itemclass$=());
      list.remove(oldIndex);
    }
    return newPosition;
  }

  public int find (=$itemclass$= find=$itemclass$=) {
    findInternal (find=$itemclass$=);
    if (findMatch) {
      return findIndex;
    } else {
      return -1;
    }
  }

  /**
   Find the appropriate insertion point or match point in the =$itemclass$= list,
   and use findIndex and findMatch to return the results.

   @param find=$itemclass$= URL we are looking for.
   */
  private void findInternal (=$itemclass$= find=$itemclass$=) {
    int low = 0;
    int high = list.size() - 1;
    findIndex = 0;
    findMatch = false;
    while (high >= low
        && findMatch == false
        && findIndex < list.size()) {
      int diff = high - low;
      int split = diff / 2;
      findIndex = low + split;
      int compare = get(findIndex).compareTo(find=$itemclass$=);
      if (compare == 0) {
        // found an exact match
        findMatch = true;
      }
      else
      if (compare < 0) {
        // =$itemclass$= from list is less than the one we're looking for
        findIndex++;
        low = findIndex;
      } else {
        // =$itemclass$= from list is greater than the one we're looking for
        if (high > findIndex) {
          high = findIndex;
        } else {
          high = findIndex - 1;
        }
      }
    } // end while looking for right position
  } // end find method
  
  public =$itemclass$=Positioned first (=$itemclass$=Positioned position) {
    if (position.navigateUsingList()) {
      return firstUsingList ();
    } else {
      return firstUsingTree ();
    }
  }
  
  public =$itemclass$=Positioned last (=$itemclass$=Positioned position) {
    if (position.navigateUsingList()) {
      return lastUsingList ();
    } else {
      return lastUsingTree ();
    }
  }

  public =$itemclass$=Positioned next (=$itemclass$=Positioned position) {
    if (position.navigateUsingList()) {
      return nextUsingList (position);
    } else {
      return nextUsingTree (position);
    }
  }

  public =$itemclass$=Positioned prior (=$itemclass$=Positioned position) {
    if (position.navigateUsingList()) {
      return priorUsingList (position);
    } else {
      return priorUsingTree (position);
    }
  }

  public =$itemclass$=Positioned firstUsingList () {
    return positionUsingListIndex (0);
  }

  public =$itemclass$=Positioned lastUsingList () {
    return positionUsingListIndex (size() - 1);
  }

  public =$itemclass$=Positioned nextUsingList (=$itemclass$=Positioned position) {
    return (positionUsingListIndex (position.getIndex() + 1));
  }

  public =$itemclass$=Positioned priorUsingList (=$itemclass$=Positioned position) {
    return (positionUsingListIndex (position.getIndex() - 1));
  }

  public =$itemclass$=Positioned positionUsingListIndex (int index) {
    if (index < 0) {
      index = 0;
    }
    if (index >= size()) {
      index = size() - 1;
    }
    =$itemclass$=Positioned position = new =$itemclass$=Positioned();
    position.setIndex (index);
    position.setNavigator (=$itemclass$=Positioned.NAVIGATE_USING_LIST);
    if (index >= 0) {
      position.set=$itemclass$= (get (index));
      position.setTagsNode (position.get=$itemclass$=().getTagsNode());
    }
    return position;
  }

  public =$itemclass$=Positioned firstUsingTree () {
    return positionUsingNode (tagsModel.firstItemNode());
  }

  public =$itemclass$=Positioned lastUsingTree () {
    return positionUsingNode (tagsModel.lastItemNode());
  }

  public =$itemclass$=Positioned nextUsingTree (=$itemclass$=Positioned position) {
    if (position.getTagsNode() == null) {
      return null;
    } else {
      return positionUsingNode
          (tagsModel.nextItemNode(position.getTagsNode()));
    }
  }

  public =$itemclass$=Positioned priorUsingTree (=$itemclass$=Positioned position) {
    if (position.getTagsNode() == null) {
      return null;
    } else {
      return positionUsingNode
          (tagsModel.priorItemNode(position.getTagsNode()));
    }
  }

}
<?endif?>
<?endif?>
<?loop?>
