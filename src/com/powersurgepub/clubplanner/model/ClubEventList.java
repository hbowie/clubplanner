package com.powersurgepub.clubplanner.model;

  import com.powersurgepub.psdatalib.pstags.*;
  import com.powersurgepub.regcodes.*;
  import java.io.*;
  import java.util.*;
  import javax.swing.table.*;

  /*
   This item master list class generated by PSTextMerge using:
 
     template:  master-list.java
     data file: fields.xls
   */

/**
 A list of ClubEvent items stored in memory.

 @author Herb Bowie
 */
public class ClubEventList
    extends AbstractTableModel
    implements TaggableList {
 
  private String          title = "Club Event List";
 
  private List<ClubEvent>            list = new ArrayList();
 
  private Comparator      comparator = new ClubEventDefaultComparator();
 
  private int             findIndex = -1;
  private boolean         findMatch = false;
 
  private TagsList        tagsList = new TagsList();
  private TagsModel       tagsModel = new TagsModel();
 
  /**
   List constructor with no arguments.
   */
  public ClubEventList () {
    tagsList.registerValue("");
  }
 
  public void setComparator (Comparator comparator) {
    this.comparator = comparator;
  }
 
  public Comparator getComparator() {
    return comparator;
  }
 
  public TagsList getTagsList () {
    return tagsList;
  }

  public TagsModel getTagsModel () {
    return tagsModel;
  }
 
  /**
   Set the data source, stored in the root node of the TagsModel tree.
 
   @param source The file or folder from which the data is taken.
  */
  public void setSource (File source) {
    tagsModel.setSource(source);
  }
 
  /**
   Get the data source, stored in the root node of the TagsModel tree.
 
   @return The file or folder from which the data is taken.
  */
  public File getSource () {
    return tagsModel.getSource();
  }
 
  public void setTitle (String title) {
    this.title = title;
  }

  public String getTitle () {
    return title;
  }
 
  /**
   Return the number of columns.
   */
  public int getColumnCount () {
    return ClubEvent.getColumnCount();
  }
 
  public String getColumnName (int columnIndex) {
    return ClubEvent.getColumnName (columnIndex);
  }

  public Class getColumnClass (int columnIndex) {
    return ClubEvent.getColumnClass (columnIndex);
  }
 
  /**
   Can more records/items be added without exceeding the demo limitation?

   @return     True if more can be added, false if we've hit the ceiling.
   */
  public boolean roomForMore() {
    return RegisterWindow.getShared().roomForMore(size());
  }
 
  /**
   Return the size of the list.
   */
  public int size() {
    return list.size();
  }

  /**
   Return the number of rows in the table.
   */
  public int getRowCount() {
    return list.size();
  }
 
  /**
   Return the column value of the item at the specified index.
   */
  public String getValueAt (int rowIndex, int columnIndex) {
    ClubEvent item = get(rowIndex);
    if (item == null) {
      return "";
    } else {
      Object columnValue = item.getColumnValue(columnIndex);
      if (columnValue == null) {
        return "";
      } else {
        return columnValue.toString();
      }
    }
  } // end method getValueAt
 
  /**
   Get the item at the specified index.
 
   @param index Indicates the desired position.
 
   @return The item at the desired index, or null if the index is out
           of bounds.
  */
  public ClubEvent get (int index) {
    if (index >= 0 && index < list.size()) {
      return list.get(index);
    } else {
      return null;
    }
  } // end method get (int)
 
  public ClubEventPositioned positionUsingNode (TagsNode node) {
    ClubEventPositioned position = new ClubEventPositioned();
    position.setClubEvent ((ClubEvent)node.getTaggable());
    position.setTagsNode (node);
    findInternal (position.getClubEvent());
    position.setIndex (findIndex);
    position.setNavigator (ClubEventPositioned.NAVIGATE_USING_TREE);
    return position;
  }
 
  /**
   Add a new ClubEvent to the list, or merge it with an existing one if another
   with the same ClubEvent already exists. Maintain the list in ascending sequence
   by the ClubEvent key.
 
   @param newClubEvent
   @return A positioned ClubEvent composed of the resulting ClubEvent and an index
           pointing to its resulting position in the list.
   */
  public ClubEventPositioned add (ClubEvent newClubEvent) {
    // System.out.println ("adding: " + newClubEvent.toString());
    // System.out.println ("URLCollection add " + newClubEvent.toString());
    // newClubEvent.getTags().displayTags();
    ClubEvent resultingClubEvent = newClubEvent;
    boolean merged = false;
    if (list.isEmpty()) {
      // If this is the first ClubEvent being added to the collection, simply add it
      list.add (newClubEvent);
      findIndex = 0;
    }
    else
    if (comparator.compare (get(list.size() - 1), newClubEvent) < 0) {
      // If the new URL has a key higher than the highest item in the
      // collection, simply add the new URL to the end
      // (more efficient if an input file happens to be pre-sorted).
      findIndex = list.size();
      list.add (newClubEvent);
    } else {
      findInternal (newClubEvent);
      if (findMatch) {
        get(findIndex).merge(newClubEvent);
        resultingClubEvent = get(findIndex);
        merged = true;
      } else {
        list.add (findIndex, newClubEvent);
      }
    }
 
    if (merged) {
      tagsList.modify  (resultingClubEvent);
      tagsModel.modify (resultingClubEvent);
    } else {
      tagsList.add  (resultingClubEvent);
      tagsModel.add (resultingClubEvent);
    }

    return new ClubEventPositioned (resultingClubEvent, findIndex);
  } // end add method

  public ClubEventPositioned modify (ClubEventPositioned modClubEvent) {
    tagsList.modify(modClubEvent.getClubEvent());
    tagsModel.modify(modClubEvent.getClubEvent());
    return modClubEvent;
  }

  /**
   Removes the passed ClubEvent, if it exists in the collection.

   @param position A position containing the ClubEvent to be removed.
 
   @return A position for the next URL following the one just removed.
   */
  public ClubEventPositioned remove (ClubEventPositioned position) {
    int oldIndex = find (position.getClubEvent());
    ClubEventPositioned newPosition = position;
    if (findMatch) {
      newPosition = next (position);
      tagsModel.remove (position.getClubEvent());
      tagsList.remove (position.getClubEvent());
      list.remove(oldIndex);
    }
    return newPosition;
  }

  public int find (ClubEvent findClubEvent) {
    findInternal (findClubEvent);
    if (findMatch) {
      return findIndex;
    } else {
      return -1;
    }
  }

  /**
   Find the appropriate insertion point or match point in the ClubEvent list,
   and use findIndex and findMatch to return the results.

   @param findClubEvent URL we are looking for.
   */
  private void findInternal (ClubEvent findClubEvent) {
    int low = 0;
    int high = list.size() - 1;
    findIndex = 0;
    findMatch = false;
    while (high >= low
        && findMatch == false
        && findIndex < list.size()) {
      int diff = high - low;
      int split = diff / 2;
      findIndex = low + split;
      int compare = comparator.compare (get(findIndex), findClubEvent);
      if (compare == 0) {
        // found an exact match
        findMatch = true;
      }
      else
      if (compare < 0) {
        // ClubEvent from list is less than the one we're looking for
        findIndex++;
        low = findIndex;
      } else {
        // ClubEvent from list is greater than the one we're looking for
        if (high > findIndex) {
          high = findIndex;
        } else {
          high = findIndex - 1;
        }
      }
    } // end while looking for right position
  } // end find method
 
  public ClubEventPositioned first (ClubEventPositioned position) {
    if (position.navigateUsingList()) {
      return firstUsingList ();
    } else {
      return firstUsingTree ();
    }
  }
 
  public ClubEventPositioned last (ClubEventPositioned position) {
    if (position.navigateUsingList()) {
      return lastUsingList ();
    } else {
      return lastUsingTree ();
    }
  }

  public ClubEventPositioned next (ClubEventPositioned position) {
    if (position.navigateUsingList()) {
      return nextUsingList (position);
    } else {
      return nextUsingTree (position);
    }
  }

  public ClubEventPositioned prior (ClubEventPositioned position) {
    if (position.navigateUsingList()) {
      return priorUsingList (position);
    } else {
      return priorUsingTree (position);
    }
  }

  public ClubEventPositioned firstUsingList () {
    return positionUsingListIndex (0);
  }

  public ClubEventPositioned lastUsingList () {
    return positionUsingListIndex (size() - 1);
  }

  public ClubEventPositioned nextUsingList (ClubEventPositioned position) {
    return (positionUsingListIndex (position.getIndex() + 1));
  }

  public ClubEventPositioned priorUsingList (ClubEventPositioned position) {
    return (positionUsingListIndex (position.getIndex() - 1));
  }

  public ClubEventPositioned positionUsingListIndex (int index) {
    if (index < 0) {
      index = 0;
    }
    if (index >= size()) {
      index = size() - 1;
    }
    ClubEventPositioned position = new ClubEventPositioned();
    position.setIndex (index);
    position.setNavigator (ClubEventPositioned.NAVIGATE_USING_LIST);
    if (index >= 0) {
      position.setClubEvent (get (index));
      position.setTagsNode (position.getClubEvent().getTagsNode());
    }
    return position;
  }

  public ClubEventPositioned firstUsingTree () {
    return positionUsingNode (tagsModel.firstItemNode());
  }

  public ClubEventPositioned lastUsingTree () {
    return positionUsingNode (tagsModel.lastItemNode());
  }

  public ClubEventPositioned nextUsingTree (ClubEventPositioned position) {
    if (position.getTagsNode() == null) {
      return null;
    } else {
      return positionUsingNode
          (tagsModel.nextItemNode(position.getTagsNode()));
    }
  }

  public ClubEventPositioned priorUsingTree (ClubEventPositioned position) {
    if (position.getTagsNode() == null) {
      return null;
    } else {
      return positionUsingNode
          (tagsModel.priorItemNode(position.getTagsNode()));
    }
  }

}
